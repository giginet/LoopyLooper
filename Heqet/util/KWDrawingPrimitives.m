//
//  KWDrawingprimitives.m
//  Heqet
//
//  Created by  on 1/12/12.
//  Copyright (c) 2012 Kawaz. All rights reserved.
//

#import <math.h>
#import <stdlib.h>
#import <string.h>

#import "KWDrawingPrimitives.h"
#import "ccTypes.h"
#import "ccMacros.h"
#import "Platforms/CCGL.h"

void ccFillPoly( const CGPoint *poli, NSUInteger numberOfPoints, BOOL closePolygon )
{
  ccVertex2F newPoint[numberOfPoints];
  
  // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
  // Needed states: GL_VERTEX_ARRAY, 
  // Unneeded states: GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY, GL_COLOR_ARRAY  
  glDisable(GL_TEXTURE_2D);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_COLOR_ARRAY);
  
  
  // iPhone and 32-bit machines
  if( sizeof(CGPoint) == sizeof(ccVertex2F) ) {
    
    // convert to pixels ?
    if( CC_CONTENT_SCALE_FACTOR() != 1 ) {
      memcpy( newPoint, poli, numberOfPoints * sizeof(ccVertex2F) );
      for( NSUInteger i=0; i<numberOfPoints;i++)
        newPoint[i] = (ccVertex2F) { poli[i].x * CC_CONTENT_SCALE_FACTOR(), poli[i].y * CC_CONTENT_SCALE_FACTOR() };
      
      glVertexPointer(2, GL_FLOAT, 0, newPoint);
      
    } else
      glVertexPointer(2, GL_FLOAT, 0, poli);
    
    
  } else {
    // 64-bit machines (Mac)
    
    for( NSUInteger i=0; i<numberOfPoints;i++)
      newPoint[i] = (ccVertex2F) { poli[i].x, poli[i].y };
    
    glVertexPointer(2, GL_FLOAT, 0, newPoint );
    
  }
  
  if( closePolygon )
    glDrawArrays(GL_TRIANGLE_FAN, 0, (GLsizei) numberOfPoints);
  else
    glDrawArrays(GL_LINE_STRIP, 0, (GLsizei) numberOfPoints);
  
  // restore default state
  glEnableClientState(GL_COLOR_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnable(GL_TEXTURE_2D);  
}

void ccFillCircle( CGPoint center, float r, float a, NSUInteger segs, BOOL drawLineToCenter)
{
  int additionalSegment = 1;
  if (drawLineToCenter)
    additionalSegment++;
  
  const float coef = 2.0f * (float)M_PI/segs;
  
  GLfloat *vertices = calloc( sizeof(GLfloat)*2*(segs+2), 1);
  if( ! vertices )
    return;
  
  for(NSUInteger i=0;i<=segs;i++)
    {
    float rads = i*coef;
    GLfloat j = r * cosf(rads + a) + center.x;
    GLfloat k = r * sinf(rads + a) + center.y;
    
    vertices[i*2] = j * CC_CONTENT_SCALE_FACTOR();
    vertices[i*2+1] =k * CC_CONTENT_SCALE_FACTOR();
    }
  vertices[(segs+1)*2] = center.x * CC_CONTENT_SCALE_FACTOR();
  vertices[(segs+1)*2+1] = center.y * CC_CONTENT_SCALE_FACTOR();
  
  // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
  // Needed states: GL_VERTEX_ARRAY, 
  // Unneeded states: GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY, GL_COLOR_ARRAY  
  glDisable(GL_TEXTURE_2D);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_COLOR_ARRAY);
  
  glVertexPointer(2, GL_FLOAT, 0, vertices);  
  glDrawArrays(GL_TRIANGLE_FAN, 0, (GLsizei) segs+additionalSegment);
  
  // restore default state
  glEnableClientState(GL_COLOR_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnable(GL_TEXTURE_2D);  
  
  free( vertices );
}

void ccFillQuadBezier(CGPoint origin, CGPoint control, CGPoint destination, NSUInteger segments)
{
  ccVertex2F vertices[segments + 1];
  
  float t = 0.0f;
  for(NSUInteger i = 0; i < segments; i++)
    {
    GLfloat x = powf(1 - t, 2) * origin.x + 2.0f * (1 - t) * t * control.x + t * t * destination.x;
    GLfloat y = powf(1 - t, 2) * origin.y + 2.0f * (1 - t) * t * control.y + t * t * destination.y;
    vertices[i] = (ccVertex2F) {x * CC_CONTENT_SCALE_FACTOR(), y * CC_CONTENT_SCALE_FACTOR() };
    t += 1.0f / segments;
    }
  vertices[segments] = (ccVertex2F) {destination.x * CC_CONTENT_SCALE_FACTOR(), destination.y * CC_CONTENT_SCALE_FACTOR() };
  
  // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
  // Needed states: GL_VERTEX_ARRAY, 
  // Unneeded states: GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY, GL_COLOR_ARRAY  
  glDisable(GL_TEXTURE_2D);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_COLOR_ARRAY);
  
  glVertexPointer(2, GL_FLOAT, 0, vertices);  
  glDrawArrays(GL_TRIANGLE_FAN, 0, (GLsizei) segments + 1);
  
  // restore default state
  glEnableClientState(GL_COLOR_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnable(GL_TEXTURE_2D);  
}

void ccFillCubicBezier(CGPoint origin, CGPoint control1, CGPoint control2, CGPoint destination, NSUInteger segments)
{
  ccVertex2F vertices[segments + 1];
  
  float t = 0;
  for(NSUInteger i = 0; i < segments; i++)
    {
    GLfloat x = powf(1 - t, 3) * origin.x + 3.0f * powf(1 - t, 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x;
    GLfloat y = powf(1 - t, 3) * origin.y + 3.0f * powf(1 - t, 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y;
    vertices[i] = (ccVertex2F) {x * CC_CONTENT_SCALE_FACTOR(), y * CC_CONTENT_SCALE_FACTOR() };
    t += 1.0f / segments;
    }
  vertices[segments] = (ccVertex2F) {destination.x * CC_CONTENT_SCALE_FACTOR(), destination.y * CC_CONTENT_SCALE_FACTOR() };
  
  // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
  // Needed states: GL_VERTEX_ARRAY, 
  // Unneeded states: GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY, GL_COLOR_ARRAY  
  glDisable(GL_TEXTURE_2D);
  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  glDisableClientState(GL_COLOR_ARRAY);
  
  glVertexPointer(2, GL_FLOAT, 0, vertices);  
  glDrawArrays(GL_TRIANGLE_FAN, 0, (GLsizei) segments + 1);
  
  // restore default state
  glEnableClientState(GL_COLOR_ARRAY);
  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
  glEnable(GL_TEXTURE_2D);  
}

void ccFillRect(CGRect rect) {
  CGPoint vertices[4];
  vertices[0] = rect.origin;
  vertices[1] = ccpAdd(rect.origin, CGPointMake(rect.size.width, 0));
  vertices[2] = ccpAdd(rect.origin, CGPointMake(rect.size.width, rect.size.height));
  vertices[3] = ccpAdd(rect.origin, CGPointMake(0, rect.size.height));
  ccFillPoly(vertices, 4, YES);
}
